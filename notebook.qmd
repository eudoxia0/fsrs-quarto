---
title: "FSRS"
format:
  html:
    code-fold: false
jupyter: python3
---

# Parameters

Retrievability $R$ is a real number in $[0, 1]$.

```{python}
R = float
```

Stability $S$ is a real number $[0, +\infty]$.

```{python}
S = float
```

Difficulty $D$ is a real number $[0, 10]$.

```{python}
D = float
```

Grade $G$ is one of:

- Forgot = 1
- Hard = 2
- Good = 3
- Easy = 4

```{python}
from enum import Enum

class Grade(Enum):
    FORGOT = 1
    HARD   = 2
    GOOD   = 3
    EASY   = 4
```

$w$ is a vector in $\mathbb{R}^{19}$.

```{python}
W: list[float] = [
    0.40255,
    1.18385,
    3.173,
    15.69105,
    7.1949,
    0.5345,
    1.4604,
    0.0046,
    1.54575,
    0.1192,
    1.01925,
    1.9395,
    0.11,
    0.29605,
    2.2698,
    0.2315,
    2.9898,
    0.51655,
    0.6621
]
```

# Retrievability

Retrievability is approximated by:

$$
R(t) = \left( 1 + F\frac{t}{S} \right)^C
$$

Where $t$ is time in days since the last review, and:

$$
\begin{align*}
F &= \frac{19}{81} \\
C &= -0.5
\end{align*}
$$

```{python}
T = float

F: float = 19.0/81.0
C: float = -0.5

def retrievability(t: T, s: S) -> R:
    return (1.0 + F*(t/s))**C
```

Retrievability curves for different values of stability:

```{python}
#| code-fold: true
import numpy as np
import matplotlib.pyplot as plt

def plot():
    t = np.linspace(0, 30, 200)
    s_values = [0.1, 0.5, 1.0, 2.0]
    for s in s_values:
        y = [retrievability(t_val, s) for t_val in t]
        plt.plot(t, y, label=f's = {s}')
    plt.xlabel('t')
    plt.ylabel('R(t)')
    plt.xlim(0, 30)
    plt.ylim(0.0, 1.0)
    plt.yticks(np.arange(0, 1.1, 0.1))
    plt.legend()
    plt.grid(True)
    plt.show()

plot()
```

# Interval

The review interval is:

$$
I = \frac{S}{F} \left( R_d^{(1/C)} - 1 \right)
$$

Where $R_d$ is the desired retention.

```{python}
def interval(rd: float, s: S) -> T:
    return (s/F)*(rd**(1.0/C) - 1.0)
```

Interval curves as a function of stability, for different values of $R_d$:

```{python}
#| code-fold: true

def plot():
    rd_curves = [0.9, 0.8, 0.7]
    for rd in rd_curves:
        s = np.linspace(0.1, 3.0, 100)
        i = [interval(rd, s_val) for s_val in s]
        plt.plot(s, i, label=f"$R_d$ = {rd}")

    plt.xlabel('S')
    plt.xlim(0.1, 3.0)
    plt.xticks(np.arange(0.0, 3.1, 0.5))

    plt.ylabel('I(S)')
    plt.ylim(0.0, 5.0)

    plt.legend()
    plt.grid(True)

    plt.show()

plot()
```

At higher $R_d$, reviews will be more frequent, which is what we expect.

Stability is defined as the interval where $R$ will equal $0.9$. So, for $R_d = 0.9$, $I(S) = S$ by definition:

```{python}
def eq(a: float, b: float) -> bool:
    return abs(a-b) < 0.001

for s in np.linspace(0.1, 3.0, 100):
    assert eq(interval(0.9, s), s)
```

# Updating Stability

This section describes how an item's stability is updated after a review.

## First Time

A card that has never been reviewed has no stability.

The first time the user reviews a card, its initial stability is:

$$
S_0(G) = w_{G-1}
$$

```{python}
def s_0(g: Grade):
    return W[g.value - 1]

assert s_0(Grade.FORGOT) == W[0]
assert s_0(Grade.HARD)   == W[1]
assert s_0(Grade.GOOD)   == W[2]
assert s_0(Grade.EASY)   == W[3]
```

That is, the parameters $w_0$ to $w_3$ represent the initial values of stability.

## Stability on Success

TODO

## Stability on Failure

TODO

# Updating Difficulty

This section describes how an item's difficulty is updated after a review.

## First Time

Analogously with stability: an item that has never been reviewed has no difficulty.

The initial difficulty, after the first review, is defined by:

$$
D_0(G) = w_4 - (G-3)w_5
$$

Note that where $G=3$ (i.e. Good) then $D_0(3) = w_4$, that is, the parameter $w_4$ represents the initial difficulty for a rating of Good, while $w_5$ is an initial difficulty multiplier.
